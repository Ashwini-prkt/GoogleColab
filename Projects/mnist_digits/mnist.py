# -*- coding: utf-8 -*-
"""mnist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D4CQ8mpu3YG_SSFpgTFZNMUnrjr7utIA
"""

# Commented out IPython magic to ensure Python compatibility.
import tensorflow as tf
from tensorflow import keras
import matplotlib.pyplot as plt
# %matplotlib inline
import numpy as np

(X_train, Y_train), (X_test,Y_test) = keras.datasets.mnist.load_data()

#print(X_train[0])
plt.matshow(X_train[0])

# try to comment this code and see the effect on results. (Normalizing the input values)
X_train = X_train/255
X_test = X_test/255

plt.matshow(X_train[0])

# converting the 3D to 2D for input purpose:
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1] * X_train.shape[2])
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1] * X_test.shape[2])

print(X_train.shape)
print(X_test.shape)

ann_model = keras.Sequential([keras.layers.Dense(10, input_shape = (784,), activation = 'sigmoid')])

#ann_model.summary()

ann_model.compile(optimizer= "adam", loss = "sparse_categorical_crossentropy", metrics='accuracy')

ann_model.fit(X_train, Y_train, epochs= 10)

ann_model.evaluate(X_test, Y_test)

prediction = ann_model.predict(X_test)
predicted_values = [np.argmax(prediction[i]) for i in range(len(prediction))]
# print(np.argmax(prediction[0]))
print(predicted_values)

conf_mat = tf.math.confusion_matrix(labels = Y_test, predictions= predicted_values)
conf_mat

import seaborn as sns
plt.figure(figsize=(10,7))
sns.heatmap(conf_mat, annot= True, fmt='d')
plt.xlabel('Actual')
plt.ylabel('Prediction')
plt.show()